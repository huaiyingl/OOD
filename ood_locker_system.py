"""
Problem:
Designing an Amazon Locker system involves multiple components, including user interaction for package pickup, delivery personnel interaction for package drop-off, and an optimal locker allocation mechanism. 
Hereâ€™s a breakdown of the requirements and a high-level design for each component:

Requirements:
- User Interaction:
    - Users should receive a code to open a locker.
    - Users should be able to open the locker using the code and pick up their package.
- Delivery Personnel Interaction:
    - Delivery personnel should be able to find an optimal locker for a package.
    - Delivery personnel should be able to place the package in the locker and mark it as occupied.
- packages -> ticket -> locker


Clarifications:
1. how many packages can be stored in one locker?
    - do all packages in one locker belong to the same user?


Reference: 
https://leetcode.com/discuss/interview-question/system-design/233869/Design-Amazon-Locker-system
https://github.com/alexandarjone/ood/blob/main/locker/locker-3/main.go


Follow up:
- more than one package in one locker
- Notification system: notify users when they have a package to pick up

"""

"""

objects:
- locker(size, status)
- package(size)
- ticket: match package to a locker (id, code, locker, packages)
- locker center: manage all lockes and user interaction
- (todo) user interface

workflow:
- system assign a locker to a package
- delivery man put pkg into a locker
- a code and a ticker is generated by the system
- user pick up pkg using the code

"""

from enum import Enum
import random
import string
from typing import List, Optional, Dict

class LockerSize(Enum):
    SMALL = 1
    MEDIUM = 2
    LARGE = 3


"""
Locker class is the most appropriate place to manage its packages because:

- Single Responsibility Principle: Each locker is responsible for what's inside it
- Information Hiding: The locker implementation can change without affecting the system
- Domain Modeling: It best represents the real-world relationship

"""

class Package:
    """Represents a package to be stored in a locker"""
    def __init__(self, size: int, user_id: str):
        self._size = size
        self._user_id = user_id

    @property
    def size(self):
        return self._size
    
    # TODO: all getters



# Locker: represents an individual locker that can hold one or more packages
class Locker:
    def __init__(self, size: LockerSize):
        self._size = size
        self._capacity = size.value
        self._is_occupied = False
        self._packages: List[Package] = []
        self._ticket: Optional[Ticket] = None
        self._user_id = None

    @property
    def size(self):
        return self._size
    
    # TODO: all getters

    def occupy(self):
        self._is_occupied = True

    def release(self):
        self._is_occupied = False

    def has_capacity(self, package):
        return self._capacity >= package.size

    # CORE
    def add_package(self, package) -> None:
        if self.has_capacity(package):
            self._packages.append(package)
            self._capacity -= package.size
            self._is_occupied = True
            # Generate a ticket for a package
            if self._ticket is None:
                self._ticket = Ticket(self)
        else:
            raise Exception("Locker does not have enough capacity")
        
    def remove_all_packages(self) -> None:
        self._packages = []
        self._capacity = self._size.value
        self._is_occupied = False
        self._user_id = None
        if self._ticket is not None:  # Check if ticket exists
            self._ticket.invalidate()
            self._ticket = None

    

# Ticket: access control of a locker using a code
class Ticket:
    def __init__(self, id, locker):
        self._locker = locker
        self._code = self.generate_code()
        self._is_valid = True

    @property
    def locker(self):
        return self._locker
    
    # TODO: all getters
    
    def generate_code(self):
        pass

    def invalidate(self):
        self._is_valid = False

    def verify_code(self, code):
        return self._is_valid and self._code == code
    

class LockerCenter:
    def __init__(self):
        self._lockers = []
        self._tickets = []
        self._locker_to_ticket = {} # locker -> ticket

    def add_locker(self, locker):
        pass

    def remove_locker(self, locker):
        pass
    
    # CORE
    def find_optimal_locker(self, package: Package) -> Optional[Locker]:
        # 1. find a locker with existing packages that has enough capacity under the same user
        for locker in self._lockers:
            if locker.is_occupied and locker.has_capacity(package) and locker.user_id == package.user_id:
                return locker

        # 2. if no locker is found, find a smalest locker with enough capacity
        suitable_lockers = [locker for locker in self._lockers 
                           if not locker.is_occupied and locker.has_capacity(package)]
        
        if suitable_lockers:
            # Sort lockers by size (smallest first)
            return min(suitable_lockers, key=lambda locker: locker._size.value)

        # 3. if no locker is found, return None
        return None
    
    def store_package(self, package: Package) -> Optional[Ticket]:
        locker = self.find_optimal_locker(package)
        if locker:
            locker.add_package(package)
            self._locker_to_ticket[locker] = locker.ticket
            return locker.ticket
        return None

    def unlock_locker(self, locker, password):
        ticket = self._locker_to_ticket.get(locker)
        if ticket.verify_code(password):
            locker.remove_all_packages()
            return True
        return False
    
# TODO: code is now stored in the ticket not the locker
# implement another version of no tickert, only the locker
        
        
        
        

